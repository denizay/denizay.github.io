<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Making a Chess Engine with Claude E. Shannon</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="../assets/css/style.css">
</head>

<body>
    <nav>
        <a href="/">Home</a>
    </nav>

    <article>
        <blockquote>
            A game between two such mental giants,<br>
            Mr. A and Mr. B, would proceed as follows.<br>
            They sit down at the chessboard, draw for colours,<br>
            and then survey the pieces for a moment.<br>
            Then either<br>
            (1) Mr. A says, "I resign" or<br>
            (2) Mr. B says, "I resign" or<br>
            (3) Mr. A says, "I offer a draw,"<br>
            and Mr. B replies, "I accept."<br>
            <span class="source">
                Programming a Computer for Playing Chess, 1950<br> Claude E. Shannon
            </span>
        </blockquote>
        <h1>Making a Chess Engine with Claude E. Shannon</h1>
        <p class="subtitle" style="margin-top: -15px; color: #666; font-style: italic;">
            Exploring Minimax, Alpha-Beta Pruning, and MVV-LVA
        </p>
        <p>
            In this post, we will examine a chess program following a proposal by <span class="person-name">Claude E.
                Shannon</span>.
        </p>
        <p>
            The algorithm at the core of the program, minimax, was first established by <span class="person-name">John
                Von
                Neumann</span> in 1927.
            <span class="person-name">Shannon</span> proposed a program that uses minimax to play chess in 1950.
            <span class="person-name">Alan Turing</span> wrote an algorithm, Turochamp, and played a match in 1952,
            executing its step manually, using himself as the computer.
            I hope, to anyone who is interested in AI, seeing these names altogether would bring at least some
            level of excitement, and hints at the rich history of programs playing games.
        </p>

        <div class="card">
            <div class="controls">
                <div class="settings-row">
                    <div class="control-group">
                        <label for="ai-depth" class="label-text">Depth</label>
                        <div class="select-wrapper">
                            <select id="ai-depth">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                                <option value="5" selected>5</option>
                                <option value="6">6</option>
                                <option value="7">7</option>
                                <option value="8">8</option>
                            </select>
                        </div>
                    </div>

                    <label class="toggle-control">
                        <input type="checkbox" id="use-pruning" checked>
                        <span class="toggle-slider"></span>
                        <span class="label-text">Pruning</span>
                    </label>

                    <label class="toggle-control">
                        <input type="checkbox" id="use-ordering" checked>
                        <span class="toggle-slider"></span>
                        <span class="label-text">Ordering</span>
                    </label>
                </div>

                <div class="actions-row">
                    <button id="restart-btn" class="btn-primary">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            style="margin-right:5px; transform: translateY(1px);">
                            <path d="M23 4v6h-6"></path>
                            <path d="M1 20v-6h6"></path>
                            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                        </svg>
                        Restart
                    </button>

                    <div class="stats-container">
                        <span id="ai-timer" class="stat-pill">0.00s</span>
                        <span id="ai-evals" class="stat-pill">0 evals</span>
                    </div>
                </div>
            </div>
            <div id="my-board" class="chess-board"></div>
        </div>

        <p>
            The program uses minimax as its core as proposed by Shannon.
            The above implementation also has alpha-beta pruning, and MVV-LVA move ordering to help with pruning
            branches
            earlier.
        </p>

        <p>
            You can turn off alpha-beta pruning to play against the exact program (Type A) Shannon described.
            The only thing changing from the user's perspective is increased thinking time without any change in the
            program's strength.
        </p>

        <hr style="margin: 30px 0; border: 0; border-top: 1px solid #eaeaea;">

        <p>
            Code for this engine was written in Rust and compiled to WebAssembly for performance.
            The Rust implementation can be found here:
        </p>

        <a href="https://github.com/denizay/denizay.github.io/tree/main/rust-engine/src/chess" target="_blank"
            class="github-card">
            <div class="github-icon">
                <svg height="24" width="24" viewBox="0 0 16 16" fill="currentColor">
                    <path
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </div>
            <div class="github-content">
                <span class="repo-name">denizay/denizay.github.io</span>
                <span class="file-name">rust-engine/src/chess</span>
            </div>
            <div class="github-arrow">→</div>
        </a>

        <p style="margin-top: 30px;">
            Throughout the post I'll show simple implementation of concepts mentioned in Python.
            The complete Python implementation can be found here:
        </p>

        <a href="https://github.com/denizay/shannon-minimax-chess" target="_blank" class="github-card">
            <div class="github-icon">
                <svg height="24" width="24" viewBox="0 0 16 16" fill="currentColor">
                    <path
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </div>
            <div class="github-content">
                <span class="repo-name">denizay/shannon-minimax-chess</span>
                <!-- <span class="file-name">Python Implementation</span> -->
            </div>
            <div class="github-arrow">→</div>
        </a>


        <h2>Evaluating a Chess board</h2>
        <p>
            If we had an exact function to evaluate a board position, we could simply check the result for every legal
            move, on average about 35, and choose the one with the highest score. However, no such computable function
            exists today. While modern engines like AlphaZero use deep neural networks to approximate this, Shannon's
            paper proposes a much simpler approach. Assigning a fixed value to each piece:
        </p>
        <div class="math-formula">
            f(P) = 200(K-K') + 9(Q-Q') + 5(R-R') + 3(B-B' + N-N') + (P-P')
        </div>
        <p>
            K, Q, R, B, N, and P are the numbers of White kings, queens, rooks, bishops, knights, and pawns on the
            board, and the primed letters are the same values for Black.
        </p>

        <div class="code-accordion">
            <div class="accordion-header" onclick="toggleCode(this)">
                <span class="accordion-title">Setting up the board in Python</span>
                <span class="accordion-icon">↓</span>
            </div>
            <div class="accordion-content">
                <pre><code class="language-python"># Shannon proposes to encode the pieces like this
E = 0	# Empty

WP = 1	# White Pawn
WN = 2	# White Knight
WB = 3	# White Bishop
WR = 4	# White Rook
WQ = 5	# White Queen
WK = 6	# White King

BP = -1	# Black Pawn
BN = -2	# Black Knight
BB = -3	# Black Bishop
BR = -4	# Black Rook
BQ = -5	# Black Queen
BK = -6	# Black King

def get_fresh_board():
    board = [
        [WR, WN, WB, WQ, WK, WB, WN, WR],
        [WP, WP, WP, WP, WP, WP, WP, WP],
        [E,  E,  E,  E,  E,  E,  E,  E],
        [E,  E,  E,  E,  E,  E,  E,  E],
        [E,  E,  E,  E,  E,  E,  E,  E],
        [E,  E,  E,  E,  E,  E,  E,  E],
        [BP, BP, BP, BP, BP, BP, BP, BP],
        [BR, BN, BB, BQ, BK, BB, BN, BR]
    ]
    return board</code></pre>
            </div>
        </div>

        <div class="code-accordion" id="code-eval">
            <div class="accordion-header" onclick="toggleCode(this)">
                <span class="accordion-title">Evaluating the board in Python</span>
                <span class="accordion-icon">↓</span>
            </div>
            <div class="accordion-content">
                <pre><code class="language-python">PIECE2POINT = {
    WP: 1, WN: 3, WB: 3, WR: 5, WQ: 9, WK: 200,
    BP: -1, BN: -3, BB: -3, BR: -5, BQ: -9, BK: -200,
    E: 0
}

def evaluate_board(board):
    total_point = 0
    for row in board:
        for piece in row:
            total_point += PIECE2POINT[piece]
    return total_point</code></pre>
            </div>
        </div>

        <p>
            White's aim is to <strong>maximize</strong> this score and the Black's is to <strong>minimize</strong>.
        </p>

        <h2>Using an evaluation function to choose a move</h2>
        <p>
            Having an approximate evaluation function, we can now start to make moves that are not completely random.
        </p>
        <p>
            Let's assume we are the White player. The simplest way to use this function is to play out every legal
            move, resulting in about 35 different positions, and choose the move that leads to the highest score. If you
            set the depth on the engine above to 1, this is the program you will be playing against (though it will be a
            very bad opponent).
        </p>
        <p>
            To make this opponent slightly stronger, we can look one step deeper. Instead of evaluating the board
            immediately after our move, we consider all possible responses available to Black.
            Since Black aims to minimize the score, we must assume they will choose the response with the lowest value.
            Therefore, we assign this minimum value as the actual score for our candidate move.
        </p>
        <p>
            If you set the depth to 2, this is the program you will be playing against. With this setting, we are
            running our evaluation function on around 35<sup>2</sup> moves.
            You can verify this number in the engine above. The number of legal moves changes throughout the game: it
            starts at 20, peaks during the middle game, and decreases as pieces are captured or when checks restrict the
            available responses. Turn off "Pruning" for now to see the numbers we are expecting with this method.
        </p>

        <figure>
            <img src="../assets/images/fig-1.png" class="blog-img">
            <figcaption>Fig 1: Minimax with depth 2</figcaption>
        </figure>

        <p>
            We can keep increasing the depth for this method as much as we want and get more accurate evaluations.
            But the number of board positions we will have to evaluate will increase exponentially as well. You can
            try playing with different depth settings and see the increase in time yourself.
        </p>

        <div class="code-accordion" id="code-minimax">
            <div class="accordion-header" onclick="toggleCode(this)">
                <span class="accordion-title">Minimax in Python</span>
                <span class="accordion-icon">↓</span>
            </div>
            <div class="accordion-content">
                <pre><code class="language-python"># get_legal_moves returns an array of moves
# each move is a tuple of (current position, target position, piece)
# each position is a tuple if integers representing rank and file
# make_move makes a move on the board and 
# returns a piece if any piece was capured
# undo_move takes the move back and puts back the captured piece

def minimax(board, color, depth):
    if depth == 0:
        return evaluate_board(board)
    best_point = float("-inf") if color == "white" else float("inf")
    legal_moves = get_legal_moves(board, color)
    for move in legal_moves:
        prev_piece = make_move(board, move)
        point = minimax(board, get_opponent(color), depth - 1)
        undo_move(board, move, prev_piece)
        if color == "white":
            best_point = max(best_point, point)
        else:
            best_point = min(best_point, point)
    return best_point</code></pre>
            </div>
        </div>


        <h2>Type A and Type B programs</h2>
        <p>
            <span class="person-name">Shannon</span> divides the types of programs that can play chess into two classes,
            called Type A and Type B.
        </p>
        <p>
            Type A programs are programs that look at every possible sequence up to a certain depth and choose the best
            move. If the game of chess was technically to be called "solved", this is the type of program we would need.
            In chess there are 35 legal moves per turn on average, this is our branching factor. Assuming an average of
            40 turns (40 moves per player) it would be around 35<sup>80</sup> ≈ 10<sup>120</sup> positions.
            In the best case scenario alpha-beta pruning reduces the branching factor to the square root of the original
            number, so (35<sup>0.5</sup>)<sup>80</sup> = 35 <sup>40</sup> ≈ 10<sup>61</sup> board positions to
            evaluate.
        </p>
        <p>
            If we calculated on an extremely optimistic speed of 10<sup>9</sup> board positions per second, we would
            still need 10<sup>52</sup> seconds to evaluate every possible position.
            The world is expected to be engulfed by the sun well within 10<sup>10</sup> years, and the universe is
            expected to be dominated by black holes within 10<sup>40</sup> years, entering The Black Hole Era. To be
            able to "solve" chess, we would need to make a computer that can withstand the decay of the universe,
            harvesting energy from the Hawking radiation of these black holes.
        </p>

        <p>
            Shannons mentions two improvements to the strategy above:
        </p>
        <p style="padding-left: 10px;">
            1 ) Examine variations out as far as a quasi-stability has been established.<br>
            Meaning don't stop exploring the branches in the middle of a trading sequence.<br>
            2 ) Select the variations to be explored so to not waste time in pointless variations.<br>
            This would require a policy function which ranks the moves to be explored.
        </p>

        <p>
            Shannon calls a strategy with these two improvements type B strategy.
        </p>

        <h2>A type A program </h2>

        <blockquote class="paper-excerpt">
            <p>
                The complete program for a type A strategy consists of nine sub-programs
                which we designate T<sub>0</sub>, <sub>1</sub>, ..., T<sub>8</sub> and a master program T<sub>9</sub>.
                The basic functions of these programs are as follows:
            </p>
            <ul class="program-list">
                <li><strong>T<sub>0</sub></strong> – Makes move <em>(a, b, c)</em> in position P to obtain the resulting
                    position.</li>
                <li><strong>T<sub>1</sub></strong> – Makes a list of the possible moves of a pawn at square <em>(x,
                        y)</em> in position P.</li>
                <li><strong>T<sub>2</sub>, ..., T<sub>6</sub></strong> – Similarly for other types of pieces: knight,
                    bishop, rook, queen and king.</li>
                <li><strong>T<sub>7</sub></strong> – Makes list of all possible moves in a given position.</li>
                <li><strong>T<sub>8</sub></strong> – Calculates the evaluating function <em>f(P)</em> for a given
                    position P.</li>
                <li><strong>T<sub>9</sub></strong> – Master program; performs maximizing and minimizing calculation to
                    determine proper move.</li>
            </ul>
            <p>
                With a given position P and a move <em>(a, b, c)</em> in the internal memory of the machine
                it can make the move and obtain the resulting position by the following program T<sub>0</sub>.
            </p>
            <span class="source">Programming a Computer for Playing Chess, 1950</span>
        </blockquote>

        <p>
            We have already implemented T<sub>8</sub> in the code block <a href="#code-eval"
                class="internal-code-link">"Evaluating the board in Python"</a>.
            Also in the code block <a href="#code-minimax" class="internal-code-link">"Minimax in Python"</a> we
            referenced
            a function called `make_move` which is our T<sub>0</sub>. T<sub>1</sub> is also relatively simple.
        </p>

        <div class="code-accordion">
            <div class="accordion-header" onclick="toggleCode(this)">
                <span class="accordion-title">List moves for a pawn in Python</span>
                <span class="accordion-icon">↓</span>
            </div>
            <div class="accordion-content">
                <pre><code class="language-python">def get_pawn_legals(board, color, position):
    legal_moves = []
    rank, file = position
    if color == 'white':
        if rank == 7:
            return []
        if board[rank+1][file] == 0:
            # Pawn going 1 square forward
            legal_moves.append((rank+1, file))
        if rank == 1 and board[rank+1][file] == 0 and board[rank+2][file] == 0:
            # Pawn going 2 squares if it's in the initial position
            legal_moves.append((rank+2, file))
        if file > 0 and board[rank+1][file-1] < 0:
            # Capturing a piece on diagonal square
            legal_moves.append((rank+1, file-1))
        if file < 7 and board[rank+1][file+1] < 0:
            # Other side diagonal
            legal_moves.append((rank+1, file+1))
    else:
        if rank == 0:
            return []
        if board[rank-1][file] == 0:
            legal_moves.append((rank-1, file))
        if rank == 6 and board[rank-1][file] == 0 and board[rank-2][file] == 0:
            legal_moves.append((rank-2, file))
        if file > 0 and board[rank-1][file-1] > 0:
            legal_moves.append((rank-1, file-1))
        if file < 7 and board[rank-1][file+1] > 0:
            legal_moves.append((rank-1, file+1))
    return legal_moves</code></pre>
            </div>
        </div>

        <p>
            Basic implementation for T<sub>2</sub>, ..., T<sub>6</sub> can be found in the repository:
        </p>

        <a href="https://github.com/denizay/shannon-minimax-chess/blob/master/pieces.py" target="_blank"
            class="github-card">
            <div class="github-icon">
                <svg height="24" width="24" viewBox="0 0 16 16" fill="currentColor">
                    <path
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </div>
            <div class="github-content">
                <span class="repo-name">denizay/shannon-minimax-chess</span>
                <span class="file-name">pieces.py</span>
            </div>
            <div class="github-arrow">→</div>
        </a>

        <p>
            T<sub>7</sub> just uses the T<sub>1</sub>, ..., T<sub>6</sub> to make a list of all legal moves.
        </p>

        <div class="code-accordion">
            <div class="accordion-header" onclick="toggleCode(this)">
                <span class="accordion-title">List all possible moves in Python</span>
                <span class="accordion-icon">↓</span>
            </div>
            <div class="accordion-content">
                <pre><code class="language-python">PIECE2FUNC = {
        WP: get_pawn_legals,
        BP: get_pawn_legals,
        WN: get_knight_legals,
        BN: get_knight_legals,
        WB: get_bishop_legals,
        BB: get_bishop_legals,
        WR: get_rook_legals,
        BR: get_rook_legals,
        WQ: get_queen_legals,
        BQ: get_queen_legals,
        WK: get_king_legals,
        BK: get_king_legals,
}
def get_legal_moves(board, color):
    all_legal_moves = []
    for rank in range(8):
        for file in range(8):
            piece = board[rank][file]
            if piece == E:
                continue
            piece_color = "white" if piece > 0 else "black"
            if piece_color != color:
                continue
            if piece in PIECE2FUNC:
                legals = PIECE2FUNC[piece](board, color, (rank, file))
                for legal in legals:
                    all_legal_moves.append(((rank, file), legal, piece))

    return all_legal_moves</code></pre>
            </div>
        </div>

        <p>
            And T<sub>9</sub> brings everything all together.
        </p>

        <div class="code-accordion">
            <div class="accordion-header" onclick="toggleCode(this)">
                <span class="accordion-title">Master program in Python</span>
                <span class="accordion-icon">↓</span>
            </div>
            <div class="accordion-content">
                <pre><code class="language-python">def minimax_player(board, color, depth):
    legal_moves = get_legal_moves(board, color)
    points_w_moves = []
    for move in legal_moves:
        prev_piece = make_move(board, move)
        point = minimax(board, get_opponent(color), depth - 1)
        points_w_moves.append((point, move))
        undo_move(board, move, prev_piece)
    # choose_random_best_move just chooses a random move among the highest scored ones
    best_point_w_move = choose_random_best_move(points_w_moves, color)
    make_move(board, best_point_w_move[1])
</code></pre>
            </div>
        </div>



        <h2>Alpha-beta Pruning</h2>
        <p>
            There is a way to help our Type A program by pruning some branches of the search tree without changing the
            algorithm's strength.
            If you look at Fig 1, we ran our evaluation function on all 9 terminal positions. However, if we assume we
            evaluate these sequentially, up to bottom, we can see that some evaluations were unnecessary
            because they could not possibly affect White's final decision.
        </p>
        <figure>
            <img src="../assets/images/fig-2.png" class="blog-img">
            <figcaption>Fig 2: Minimax, with alpha-beta pruning, with depth 2<br>Greyed out branches are not needed to
                be evaluated.</figcaption>
        </figure>
        <p>
            After evaluating the first possible move, White knows that the best it can do so far is +2.
            When looking at the second White possible move, as soon as we see a score that is lower than +2, which is -2
            in the figure above, we can stop looking at the rest of the Black moves.
        </p>
        <p>
            Since Black plays to minimize the score, once they have the option to force the game to -2, the value of
            this entire branch becomes at most -2. Because White can already guarantee a +2 from the
            first move, White will never choose this second branch.
        </p>
        <p>
            This means the +2 we found becomes our <strong>lower bound</strong>. Any time we see a response resulting in
            a score lower than this lower bound, we can be sure that we will not go with that branch and we can stop
            looking at the other sub-branches. As White keeps exploring, it could find branches resulting in scores
            higher than +2, and we would increase the lower bound with these new values.
        </p>
        <p>
            Just keeping track of a lower bound allows us to only prune one side's moves. We also need to keep track of
            the <strong>upper bound</strong> of the score for Black. We keep track of these scores by adding two new
            variables to our
            existing minimax implementation. The lower bound is kept track in a variable called <strong>Alpha</strong>
            and the upper bound in <strong>Beta</strong>.
        </p>

        <div class="code-accordion">
            <div class="accordion-header" onclick="toggleCode(this)">
                <span class="accordion-title">Minimax with alpha-beta pruning in Python</span>
                <span class="accordion-icon">↓</span>
            </div>
            <div class="accordion-content">
                <pre><code class="language-python">def minimax(board, color, depth, alpha=float("-inf"), beta=float("inf")):
    if depth == 0:
        return evaluate_board(board)
    best_point = float("-inf") if color == "white" else float("inf")
    legal_moves = get_legal_moves(board, color)
    for move in legal_moves:
        prev_piece = make_move(board, move)
        point = minimax(board, get_opponent(color), depth - 1, alpha, beta)
        undo_move(board, move, prev_piece)
        if color == "white":
            best_point = max(best_point, point)
            alpha = max(alpha, point)
            if beta <= alpha:
                break
        else:
            best_point = min(best_point, point)
            beta = min(beta, point)
            if beta <= alpha:
                break
    return best_point</code></pre>
            </div>
        </div>

        <p>
            The idea was conceived by <strong>John McCarthy</strong> during the famous 1956 Dartmouth conference.
        </p>
        <blockquote class="paper-excerpt">
            "McCarthy thought of the method during the Dartmouth Summer Research Conference on Artificial Intelligence
            in 1956, when Bernstein described an early chess program which didn't use any sort of alpha-beta."
            <span class="source">
                An Analysis of Alpha-Beta Pruning, 1975<br> Donald E. Knuth, Ronald W. Mooree
            </span>
        </blockquote>
        <p>
            This is the very same conference where the term <strong>"Artificial Intelligence"</strong> was first coined.
            The proposal for this historic gathering was co-authored by John McCarthy, Marvin Minsky, Nathaniel
            Rochester, and <span class="person-name">Claude E. Shannon</span>.
        </p>

        <h3>MVV-LVA</h3>
        <p>
            The efficiency of alpha-beta pruning relies heavily on the order we examine moves. If we examine the
            best moves first, we can prune the remaining bad branches much earlier.
            Since we don't know the true "best" move yet, we use heuristics to guess which moves are likely to be good.
        </p>
        <p>
            A popular method for sorting captures is called MVV-LVA(Most Valuable Victim - Least
            Valuable Aggressor).
        <ul class="heuristic-list">
            <li>Most Valuable Victim (MVV): If we have a choice of pieces to capture, we look at
                capturing the most valuable one first, for example: capturing a queen is likely to be better than
                capturing a pawn.
            </li>
            <li>Least Valuable Aggressor (LVA): If we can capture a piece with multiple different
                pieces, we start with the least valuable attacker, capturing with a pawn is likely to be safer than
                capturing with a queen.</li>
        </ul>
        By prioritizing moves where we gain the most material while risking the least, we maximize the chances of
        finding a "good enough" move early, which triggers a cutoff for the rest.
        </p>

        <figure>
            <img src="../assets/images/fig-3.png" class="blog-img">
            <figcaption>Fig 3: Minimax, with Alpha-Beta pruning, with MVV-LVA ordering, with depth 2</figcaption>
        </figure>

        <p>
            To illustrate the impact of these improvements, we can look at the number of positions the engine above
            evaluates to find a response to the opening move 1. e4 at depth 6:
        <ul class="stats-list">
            <li>Minimax: 309,392,030 positions</li>
            <li>Alpha-Beta Pruning: 3,000,909 positions</li>
            <li>With MVV-LVA Ordering: 1,175,609 positions</li>
        </ul>
        I would urge the reader to play around with different moves and depth settings to see the effects of these
        improvements.
        </p>


    </article>

    <script type="module">
        import { ChessBoard } from '../assets/js/chess-ui.js';
        new ChessBoard('my-board', null);
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleCode(headerElement) {
            // Toggle the arrow rotation
            headerElement.classList.toggle('active');

            // Find the content div immediately following the header
            const content = headerElement.nextElementSibling;

            // Toggle visibility
            content.classList.toggle('open');
        }

        // Attach to window so the HTML onclick works
        window.toggleCode = toggleCode;

        // Auto-scroll handler for internal code links
        document.querySelectorAll('.internal-code-link').forEach(link => {
            link.addEventListener('click', (e) => {
                // 1. Get the target ID
                const targetId = link.getAttribute('href').substring(1);
                const targetBlock = document.getElementById(targetId);

                if (targetBlock) {
                    // 2. Find the header inside that block
                    const header = targetBlock.querySelector('.accordion-header');

                    // 3. If it's not already open, toggle it
                    if (header && !header.classList.contains('active')) {
                        toggleCode(header);
                    }
                }
            });
        });
    </script>
</body>

</html>